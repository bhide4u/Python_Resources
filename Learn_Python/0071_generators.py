# Generators

# Generators in Python are a type of iterable, which allows you to generate a sequence of values on-the-fly without storing them in memory. They are implemented using the 'yield' keyword and provide an efficient way to generate large and potentially infinite sequences of values. Here are five different examples that demonstrate the usage of generators in Python:

# Example 1: Simple Counter

def counter():
    i = 0
    while True:
        yield i
        i += 1

# Create a generator object
my_counter = counter()

# Generate and print the first five numbers
for _ in range(5):
    print(next(my_counter))

# Output: 0, 1, 2, 3, 4

# In this example, the 'counter' function is a generator that generates an infinite sequence of numbers starting from zero. Each time the 'yield' statement is encountered, the current value of 'i' is returned as the next value in the sequence. The generator is used in a loop to print the first five numbers.

Example 2: Fibonacci Sequence

def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# Create a generator object
fib_gen = fibonacci()

# Generate and print the first ten Fibonacci numbers
for _ in range(10):
    print(next(fib_gen))

# Output: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34

# In this example, the 'fibonacci' generator generates an infinite sequence of Fibonacci numbers. The 'yield' statement returns the current Fibonacci number, and the variables 'a' and 'b' are updated to calculate the next number in the sequence.

# Example 3: Filtering Numbers

def even_numbers(numbers):
    for num in numbers:
        if num % 2 == 0:
            yield num

# Create a generator object
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_gen = even_numbers(numbers)

# Generate and print only the even numbers
for even_num in even_gen:
    print(even_num)

# Output: 2, 4, 6, 8, 10

# In this example, the 'even_numbers' generator takes a list of numbers as input and yields only the even numbers. It filters out the odd numbers and returns only the even numbers in the sequence.

# Example 4: File Reading

def read_lines(filename):
    with open(filename, 'r') as file:
        for line in file:
            yield line.strip()

# Create a generator object
lines_gen = read_lines('my_file.txt')

# Generate and print each line of the file
for line in lines_gen:
    print(line)

# Output: contents of the file line by line

# In this example, the 'read_lines' generator reads a file line by line and yields each line as a string. It uses a 'with' statement to ensure the file is properly closed after reading.

# Example 5: Infinite Sequence

def infinite_sequence():
    num = 1
    while True:
        yield num
        num += 1

# Create a generator object
my_seq = infinite_sequence()

# Generate and print the first ten numbers
for _ in range(10):
    print(next(my_seq))

# Output: 1, 2, 3, 4, 5, 6, 7, 8, 9, 

10

# In this example, the 'infinite_sequence' generator generates an infinite sequence of numbers starting from one. It continually yields the next number in the sequence as it is requested.

# Generators provide an elegant way to work with large or infinite sequences of values, as they generate values on-the-fly without occupying excessive memory. They are useful for scenarios such as iterating over large datasets, handling streaming data, or generating sequences dynamically.


# In Python, the 'yield' keyword is used in the context of generators. It allows a function to be defined as a generator, which can generate a sequence of values on-the-fly. When the 'yield' statement is encountered in a generator function, it pauses the execution of the function, saves its internal state, and yields a value to the caller. The generator function can later be resumed from where it left off, continuing its execution.

# Here's a breakdown of how 'yield' works in the context of generators:

# 1. Generator Function: A generator function is defined using the 'def' keyword, just like any other function. However, instead of using the 'return' statement, a generator function uses the 'yield' statement to yield a value.

# 2. Generator Object: When a generator function is called, it returns a generator object. The generator object is an iterator that can be used to iterate over the sequence of values generated by the generator function.

# 3. Yielding Values: When the generator function encounters a 'yield' statement, it temporarily suspends its execution and returns the yielded value to the caller. The state of the generator function is saved, allowing it to resume from where it left off when it is called again.

# 4. Resuming Execution: When the generator object's 'next()' function or the built-in 'next()' function is called on the generator object, the generator function resumes its execution from where it was paused, immediately after the 'yield' statement. The next value in the sequence is generated and returned.

# 5. Iterating Over Values: The generator object can be iterated over using a 'for' loop, which automatically calls the 'next()' function on the generator object for each iteration. The loop continues until the generator function has no more values to yield.

# Here's an example to illustrate the concept:


def my_generator():
    yield 'Hello'
    yield 'World'
    yield 'Generator'

# Create a generator object
gen = my_generator()

# Iterating over the generator values
for value in gen:
    print(value)

# Output: Hello, World, Generator


# In this example, the 'my_generator()' function is defined as a generator function. It yields three values: 'Hello', 'World', and 'Generator'. When the generator object 'gen' is iterated over using the 'for' loop, the generator function is executed. It pauses at each 'yield' statement, yielding the corresponding value. The loop prints each yielded value.

# The key idea behind using 'yield' is that it allows the generator function to generate values on-the-fly, rather than generating and storing all values in memory at once. This makes generators memory-efficient, especially when dealing with large or infinite sequences of values.

# The 'yield' keyword provides a powerful mechanism for implementing iterators and generators in Python, enabling the generation of values in a lazy and efficient manner.
